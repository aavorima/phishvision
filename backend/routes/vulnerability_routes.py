"""
Vulnerability Analysis API Routes

Endpoints for managing and querying vulnerability profiles.
"""

from flask import Blueprint, request, jsonify, session
from database import db
from models import (
    User, Employee, VulnerabilityProfile, ProfileDataPoint,
    DepartmentVulnerability, AgeGroupVulnerability
)
from services.vulnerability_analyzer import VulnerabilityAnalyzer

bp = Blueprint('vulnerability', __name__, url_prefix='/api/vulnerability')

# Initialize service
vulnerability_analyzer = VulnerabilityAnalyzer()


def get_current_user():
    """Helper to get current user from session"""
    user_id = session.get('user_id')
    if not user_id:
        return None
    return User.query.get(user_id)


def require_auth(f):
    """Decorator to require authentication"""
    from functools import wraps
    @wraps(f)
    def decorated(*args, **kwargs):
        if not get_current_user():
            return jsonify({'error': 'Authentication required'}), 401
        return f(*args, **kwargs)
    return decorated


# =============================================================================
# INDIVIDUAL EMPLOYEE PROFILES
# =============================================================================

@bp.route('/profile/<employee_id>', methods=['GET'])
@require_auth
def get_employee_profile(employee_id):
    """
    Get vulnerability profile for a specific employee.

    Query params:
    - include_data_points: Include historical data points (default: false)
    """
    include_data_points = request.args.get('include_data_points', 'false').lower() == 'true'

    profile = VulnerabilityProfile.query.filter_by(employee_id=employee_id).first()
    if not profile:
        return jsonify({'error': 'Profile not found', 'employee_id': employee_id}), 404

    employee = Employee.query.get(employee_id)

    result = profile.to_dict(include_data_points=include_data_points)
    if employee:
        result['employee'] = employee.to_dict()

    return jsonify(result)


@bp.route('/profile/<employee_id>/summary', methods=['GET'])
@require_auth
def get_employee_summary(employee_id):
    """Get comprehensive vulnerability summary for an employee"""
    summary = vulnerability_analyzer.get_employee_vulnerability_summary(employee_id)

    if not summary:
        return jsonify({'error': 'Employee or profile not found'}), 404

    return jsonify(summary)


@bp.route('/profile/<employee_id>/calculate', methods=['POST'])
@require_auth
def recalculate_employee_profile(employee_id):
    """Manually trigger profile recalculation for an employee"""
    profile = VulnerabilityProfile.query.filter_by(employee_id=employee_id).first()

    if not profile:
        # Create new profile
        profile = vulnerability_analyzer.get_or_create_profile(employee_id)

    # Recalculate all metrics
    profile.find_weakest_areas()
    profile.calculate_profile_confidence()
    profile.calculate_risk_level()

    db.session.commit()

    return jsonify({
        'success': True,
        'profile': profile.to_dict()
    })


@bp.route('/profiles', methods=['GET'])
@require_auth
def get_all_profiles():
    """
    Get all vulnerability profiles with filtering and sorting.

    Query params:
    - department: Filter by department
    - risk_level: Filter by risk level (low, medium, high, critical)
    - min_score: Minimum vulnerability score
    - max_score: Maximum vulnerability score
    - sort_by: Field to sort by (default: overall_vulnerability_score)
    - order: asc or desc (default: desc)
    - page: Page number (default: 1)
    - per_page: Items per page (default: 20)
    """
    # Get filter params
    department = request.args.get('department')
    risk_level = request.args.get('risk_level')
    min_score = request.args.get('min_score', type=float)
    max_score = request.args.get('max_score', type=float)
    sort_by = request.args.get('sort_by', 'overall_vulnerability_score')
    order = request.args.get('order', 'desc')
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)

    # Build query
    query = VulnerabilityProfile.query

    # Join with Employee for department filtering
    if department:
        query = query.join(Employee).filter(Employee.department == department)

    if risk_level:
        query = query.filter(VulnerabilityProfile.risk_level == risk_level)

    if min_score is not None:
        query = query.filter(VulnerabilityProfile.overall_vulnerability_score >= min_score)

    if max_score is not None:
        query = query.filter(VulnerabilityProfile.overall_vulnerability_score <= max_score)

    # Sorting
    sort_column = getattr(VulnerabilityProfile, sort_by, VulnerabilityProfile.overall_vulnerability_score)
    if order == 'desc':
        query = query.order_by(sort_column.desc())
    else:
        query = query.order_by(sort_column.asc())

    # Pagination
    pagination = query.paginate(page=page, per_page=per_page, error_out=False)

    # Build response with employee info
    profiles = []
    for profile in pagination.items:
        profile_dict = profile.to_dict()
        employee = Employee.query.get(profile.employee_id)
        if employee:
            profile_dict['employee'] = employee.to_dict()
        profiles.append(profile_dict)

    return jsonify({
        'profiles': profiles,
        'pagination': {
            'page': page,
            'per_page': per_page,
            'total': pagination.total,
            'pages': pagination.pages
        }
    })


# =============================================================================
# DEPARTMENT ANALYSIS
# =============================================================================

@bp.route('/departments', methods=['GET'])
@require_auth
def get_all_departments():
    """Get vulnerability summary for all departments"""
    departments = DepartmentVulnerability.query.order_by(
        DepartmentVulnerability.avg_vulnerability_score.desc()
    ).all()

    return jsonify({
        'departments': [d.to_dict() for d in departments],
        'total': len(departments)
    })


@bp.route('/department/<department>', methods=['GET'])
@require_auth
def get_department_vulnerability(department):
    """Get detailed vulnerability analysis for a specific department"""
    dept_vuln = DepartmentVulnerability.query.filter_by(department=department).first()

    if not dept_vuln:
        # Calculate it
        dept_vuln = vulnerability_analyzer.calculate_department_vulnerability(department)

    # Get high-risk employees in this department
    employees = Employee.query.filter_by(department=department, is_active=True).all()
    employee_ids = [e.id for e in employees]

    high_risk_profiles = VulnerabilityProfile.query.filter(
        VulnerabilityProfile.employee_id.in_(employee_ids),
        VulnerabilityProfile.overall_vulnerability_score >= 70
    ).all()

    high_risk_employees = []
    for profile in high_risk_profiles:
        employee = Employee.query.get(profile.employee_id)
        if employee:
            high_risk_employees.append({
                'employee': employee.to_dict(),
                'vulnerability_score': profile.overall_vulnerability_score,
                'risk_level': profile.risk_level,
                'weakest_technique': profile.weakest_technique
            })

    result = dept_vuln.to_dict()
    result['high_risk_employees'] = high_risk_employees

    return jsonify(result)


@bp.route('/department/<department>/calculate', methods=['POST'])
@require_auth
def recalculate_department(department):
    """Manually trigger department vulnerability recalculation"""
    dept_vuln = vulnerability_analyzer.calculate_department_vulnerability(department)

    return jsonify({
        'success': True,
        'department': dept_vuln.to_dict()
    })


# =============================================================================
# AGE GROUP ANALYSIS
# =============================================================================

@bp.route('/age-groups', methods=['GET'])
@require_auth
def get_all_age_groups():
    """Get vulnerability analysis for all age groups"""
    age_groups = AgeGroupVulnerability.query.order_by(
        AgeGroupVulnerability.avg_vulnerability_score.desc()
    ).all()

    return jsonify({
        'age_groups': [ag.to_dict() for ag in age_groups],
        'total': len(age_groups)
    })


@bp.route('/age-group/<age_group>', methods=['GET'])
@require_auth
def get_age_group_vulnerability(age_group):
    """Get detailed vulnerability analysis for a specific age group"""
    age_vuln = AgeGroupVulnerability.query.filter_by(age_group=age_group).first()

    if not age_vuln:
        # Calculate it
        age_vuln = vulnerability_analyzer.calculate_age_group_vulnerability(age_group)

    return jsonify(age_vuln.to_dict())


@bp.route('/age-group/<age_group>/calculate', methods=['POST'])
@require_auth
def recalculate_age_group(age_group):
    """Manually trigger age group vulnerability recalculation"""
    age_vuln = vulnerability_analyzer.calculate_age_group_vulnerability(age_group)

    return jsonify({
        'success': True,
        'age_group': age_vuln.to_dict()
    })


# =============================================================================
# TECHNIQUE ANALYSIS
# =============================================================================

@bp.route('/techniques', methods=['GET'])
@require_auth
def get_technique_effectiveness():
    """
    Get effectiveness of each psychological technique across the organization.
    Shows which techniques employees are most vulnerable to.
    """
    profiles = VulnerabilityProfile.query.all()

    if not profiles:
        return jsonify({
            'techniques': {},
            'most_effective': None,
            'least_effective': None
        })

    # Calculate averages for each technique
    techniques = {
        'urgency': {'total': 0, 'name': 'Urgency', 'description': '"Act now!" tactics'},
        'authority': {'total': 0, 'name': 'Authority', 'description': '"CEO needs this"'},
        'curiosity': {'total': 0, 'name': 'Curiosity', 'description': '"You won\'t believe..."'},
        'fear': {'total': 0, 'name': 'Fear', 'description': '"Account suspended"'},
        'reward': {'total': 0, 'name': 'Reward', 'description': '"You\'ve won!"'},
        'social_proof': {'total': 0, 'name': 'Social Proof', 'description': '"Everyone is doing..."'}
    }

    for profile in profiles:
        techniques['urgency']['total'] += profile.urgency_susceptibility
        techniques['authority']['total'] += profile.authority_susceptibility
        techniques['curiosity']['total'] += profile.curiosity_susceptibility
        techniques['fear']['total'] += profile.fear_susceptibility
        techniques['reward']['total'] += profile.reward_susceptibility
        techniques['social_proof']['total'] += profile.social_proof_susceptibility

    # Calculate averages
    count = len(profiles)
    for tech in techniques:
        techniques[tech]['avg_susceptibility'] = round(techniques[tech]['total'] / count, 1)
        del techniques[tech]['total']

    # Find most and least effective
    sorted_techniques = sorted(techniques.items(), key=lambda x: x[1]['avg_susceptibility'], reverse=True)

    return jsonify({
        'techniques': techniques,
        'most_effective': sorted_techniques[0][0] if sorted_techniques else None,
        'least_effective': sorted_techniques[-1][0] if sorted_techniques else None,
        'ranking': [{'technique': t, **data} for t, data in sorted_techniques]
    })


# =============================================================================
# HIGH RISK EMPLOYEES
# =============================================================================

@bp.route('/high-risk', methods=['GET'])
@require_auth
def get_high_risk_employees():
    """
    Get list of highest risk employees.

    Query params:
    - threshold: Minimum score to be considered high risk (default: 70)
    - limit: Maximum number of results (default: 20)
    """
    threshold = request.args.get('threshold', 70.0, type=float)
    limit = request.args.get('limit', 20, type=int)

    high_risk = vulnerability_analyzer.get_high_risk_employees(threshold=threshold, limit=limit)

    return jsonify({
        'high_risk_employees': high_risk,
        'total': len(high_risk),
        'threshold': threshold
    })


@bp.route('/repeat-offenders', methods=['GET'])
@require_auth
def get_repeat_offenders():
    """Get employees who have failed multiple phishing tests"""
    profiles = VulnerabilityProfile.query.filter(
        VulnerabilityProfile.consecutive_failures >= 3
    ).order_by(
        VulnerabilityProfile.consecutive_failures.desc()
    ).all()

    repeat_offenders = []
    for profile in profiles:
        employee = Employee.query.get(profile.employee_id)
        if employee:
            repeat_offenders.append({
                'employee': employee.to_dict(),
                'consecutive_failures': profile.consecutive_failures,
                'total_clicked': profile.total_links_clicked,
                'total_credentials_submitted': profile.total_credentials_submitted,
                'last_incident': profile.last_incident_date.isoformat() if profile.last_incident_date else None,
                'vulnerability_score': profile.overall_vulnerability_score
            })

    return jsonify({
        'repeat_offenders': repeat_offenders,
        'total': len(repeat_offenders)
    })


# =============================================================================
# TRENDS AND INSIGHTS
# =============================================================================

@bp.route('/trends', methods=['GET'])
@require_auth
def get_vulnerability_trends():
    """
    Get vulnerability trends over time.

    Query params:
    - days: Number of days to look back (default: 90)
    """
    days = request.args.get('days', 90, type=int)

    from datetime import datetime, timedelta
    cutoff = datetime.utcnow() - timedelta(days=days)

    # Get data points in time range
    data_points = ProfileDataPoint.query.filter(
        ProfileDataPoint.recorded_at >= cutoff
    ).order_by(ProfileDataPoint.recorded_at.asc()).all()

    if not data_points:
        return jsonify({
            'trends': [],
            'summary': {
                'total_tests': 0,
                'click_rate': 0,
                'trend': 'stable'
            }
        })

    # Group by week
    weekly_data = {}
    for dp in data_points:
        week_start = dp.recorded_at - timedelta(days=dp.recorded_at.weekday())
        week_key = week_start.strftime('%Y-%m-%d')

        if week_key not in weekly_data:
            weekly_data[week_key] = {'total': 0, 'clicked': 0, 'submitted': 0}

        weekly_data[week_key]['total'] += 1
        if dp.link_clicked:
            weekly_data[week_key]['clicked'] += 1
        if dp.credentials_submitted:
            weekly_data[week_key]['submitted'] += 1

    # Calculate rates
    trends = []
    for week, data in sorted(weekly_data.items()):
        trends.append({
            'week': week,
            'total_tests': data['total'],
            'click_rate': round((data['clicked'] / data['total'] * 100), 1) if data['total'] > 0 else 0,
            'submission_rate': round((data['submitted'] / data['total'] * 100), 1) if data['total'] > 0 else 0
        })

    # Calculate overall trend
    if len(trends) >= 2:
        first_half = trends[:len(trends)//2]
        second_half = trends[len(trends)//2:]

        first_avg = sum(t['click_rate'] for t in first_half) / len(first_half)
        second_avg = sum(t['click_rate'] for t in second_half) / len(second_half)

        if second_avg < first_avg - 5:
            trend = 'improving'
        elif second_avg > first_avg + 5:
            trend = 'declining'
        else:
            trend = 'stable'
    else:
        trend = 'stable'

    total_tests = sum(d['total'] for d in weekly_data.values())
    total_clicked = sum(d['clicked'] for d in weekly_data.values())

    return jsonify({
        'trends': trends,
        'summary': {
            'total_tests': total_tests,
            'click_rate': round((total_clicked / total_tests * 100), 1) if total_tests > 0 else 0,
            'trend': trend
        }
    })


# =============================================================================
# ORGANIZATION SUMMARY
# =============================================================================

@bp.route('/summary', methods=['GET'])
@require_auth
def get_organization_summary():
    """Get organization-wide vulnerability summary"""
    summary = vulnerability_analyzer.get_organization_summary()
    return jsonify(summary)


# =============================================================================
# BATCH OPERATIONS
# =============================================================================

@bp.route('/recalculate-all', methods=['POST'])
@require_auth
def recalculate_all_profiles():
    """
    Batch recalculation of all vulnerability data.
    This may take some time for large organizations.
    """
    user = get_current_user()
    if not user or user.role != 'admin':
        return jsonify({'error': 'Admin access required'}), 403

    results = vulnerability_analyzer.recalculate_all_profiles()

    return jsonify({
        'success': True,
        'results': results
    })


@bp.route('/initialize-profiles', methods=['POST'])
@require_auth
def initialize_all_profiles():
    """
    Create vulnerability profiles for all employees who don't have one.
    """
    user = get_current_user()
    if not user or user.role != 'admin':
        return jsonify({'error': 'Admin access required'}), 403

    employees = Employee.query.filter_by(is_active=True).all()
    created = 0

    for employee in employees:
        existing = VulnerabilityProfile.query.filter_by(employee_id=employee.id).first()
        if not existing:
            profile = VulnerabilityProfile(employee_id=employee.id)
            db.session.add(profile)
            created += 1

    db.session.commit()

    return jsonify({
        'success': True,
        'profiles_created': created,
        'total_employees': len(employees)
    })
