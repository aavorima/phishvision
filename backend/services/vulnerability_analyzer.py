"""
Vulnerability Analysis Service

Responsibilities:
1. Calculate individual vulnerability scores after each campaign interaction
2. Aggregate department-level vulnerabilities
3. Analyze age group patterns
4. Identify technique susceptibilities
5. Track improvement/decline trends
6. Recalculate all profiles on demand
"""

from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import json

from database import db
from models import (
    Employee, VulnerabilityProfile, ProfileDataPoint,
    DepartmentVulnerability, AgeGroupVulnerability,
    ScheduledCampaign, CampaignTarget, CustomTemplate
)


class VulnerabilityAnalyzer:
    """
    Core service for calculating and managing vulnerability profiles.
    """

    # Score adjustment constants
    CLICK_PENALTY = 10  # Points added for clicking
    CREDENTIAL_PENALTY = 20  # Points added for credential submission
    PASS_BONUS = -5  # Points removed for passing (not clicking)
    REPORT_BONUS = -8  # Points removed for correctly reporting phishing
    FAST_CLICK_THRESHOLD = 60  # Seconds - clicks faster than this are more impulsive
    FAST_CLICK_EXTRA_PENALTY = 5  # Extra penalty for impulsive clicking

    # Difficulty multipliers (harder tests have less impact on score)
    DIFFICULTY_MULTIPLIERS = {
        'easy': 1.0,
        'medium': 0.8,
        'hard': 0.6,
        'expert': 0.4
    }

    def __init__(self):
        pass

    def get_or_create_profile(self, employee_id: str) -> VulnerabilityProfile:
        """Get existing profile or create new one for employee"""
        profile = VulnerabilityProfile.query.filter_by(employee_id=employee_id).first()
        if not profile:
            profile = VulnerabilityProfile(employee_id=employee_id)
            db.session.add(profile)
            db.session.flush()
        return profile

    def record_campaign_result(
        self,
        employee_id: str,
        template_id: str,
        vector_type: str = 'email',
        difficulty_level: str = 'medium',
        email_opened: bool = False,
        link_clicked: bool = False,
        credentials_submitted: bool = False,
        reported_as_phishing: bool = False,
        time_to_open_seconds: Optional[int] = None,
        time_to_click_seconds: Optional[int] = None,
        time_to_submit_seconds: Optional[int] = None,
        device_type: Optional[str] = None,
        program_id: Optional[str] = None,
        scheduled_campaign_id: Optional[str] = None
    ) -> Dict:
        """
        Record a campaign interaction and update vulnerability profile.

        Returns dict with updated profile data and score changes.
        """
        profile = self.get_or_create_profile(employee_id)

        # Get technique from template
        template = CustomTemplate.query.get(template_id)
        technique_tested = template.technique_type if template else None

        # Determine time context
        now = datetime.utcnow()
        time_of_day = self._get_time_of_day(now)
        day_of_week = now.strftime('%A')

        # Create data point record
        data_point = ProfileDataPoint(
            profile_id=profile.id,
            employee_id=employee_id,
            program_id=program_id,
            scheduled_campaign_id=scheduled_campaign_id,
            technique_tested=technique_tested,
            vector_type=vector_type,
            difficulty_level=difficulty_level,
            email_opened=email_opened,
            link_clicked=link_clicked,
            credentials_submitted=credentials_submitted,
            reported_as_phishing=reported_as_phishing,
            time_to_open_seconds=time_to_open_seconds,
            time_to_click_seconds=time_to_click_seconds,
            time_to_submit_seconds=time_to_submit_seconds,
            device_type=device_type,
            time_of_day=time_of_day,
            day_of_week=day_of_week
        )

        # Calculate score impact
        score_impact = self._calculate_score_impact(
            link_clicked=link_clicked,
            credentials_submitted=credentials_submitted,
            reported_as_phishing=reported_as_phishing,
            time_to_click_seconds=time_to_click_seconds,
            difficulty_level=difficulty_level
        )
        data_point.score_impact = score_impact

        db.session.add(data_point)

        # Update profile statistics
        profile.total_campaigns_received += 1
        profile.data_points_count += 1

        if email_opened:
            profile.total_emails_opened += 1

        if link_clicked:
            profile.total_links_clicked += 1
            profile.consecutive_passes = 0
            profile.consecutive_failures += 1
            profile.last_incident_date = now
        else:
            profile.consecutive_passes += 1
            profile.consecutive_failures = 0

        if credentials_submitted:
            profile.total_credentials_submitted += 1

        if reported_as_phishing:
            profile.total_reported_correctly += 1

        # Update average click time
        if time_to_click_seconds is not None:
            if profile.avg_click_time_seconds is None:
                profile.avg_click_time_seconds = float(time_to_click_seconds)
            else:
                # Running average
                count = profile.total_links_clicked
                profile.avg_click_time_seconds = (
                    (profile.avg_click_time_seconds * (count - 1) + time_to_click_seconds) / count
                )

        # Update vector-specific score
        self._update_vector_score(profile, vector_type, score_impact)

        # Update technique-specific score
        if technique_tested:
            self._update_technique_score(profile, technique_tested, score_impact)

        # Recalculate overall score
        self._recalculate_overall_score(profile)

        # Update temporal patterns
        self._update_temporal_patterns(profile, time_of_day, day_of_week, link_clicked)

        # Calculate improvement trend
        self._calculate_improvement_trend(profile)

        # Find weakest areas
        profile.find_weakest_areas()

        # Calculate profile confidence
        profile.calculate_profile_confidence()

        # Calculate risk level
        profile.calculate_risk_level()

        profile.updated_at = now
        db.session.commit()

        return {
            'profile': profile.to_dict(),
            'data_point': data_point.to_dict(),
            'score_impact': score_impact
        }

    def _calculate_score_impact(
        self,
        link_clicked: bool,
        credentials_submitted: bool,
        reported_as_phishing: bool,
        time_to_click_seconds: Optional[int],
        difficulty_level: str
    ) -> float:
        """Calculate the score impact of a campaign interaction"""
        impact = 0.0
        multiplier = self.DIFFICULTY_MULTIPLIERS.get(difficulty_level, 0.8)

        if link_clicked:
            impact += self.CLICK_PENALTY * multiplier

            # Extra penalty for fast (impulsive) clicks
            if time_to_click_seconds and time_to_click_seconds < self.FAST_CLICK_THRESHOLD:
                impact += self.FAST_CLICK_EXTRA_PENALTY * multiplier

        if credentials_submitted:
            impact += self.CREDENTIAL_PENALTY * multiplier

        if reported_as_phishing:
            impact += self.REPORT_BONUS * multiplier

        # Bonus for passing (not clicking)
        if not link_clicked:
            impact += self.PASS_BONUS * multiplier

        return impact

    def _update_vector_score(self, profile: VulnerabilityProfile, vector_type: str, impact: float):
        """Update the score for a specific attack vector"""
        vector_map = {
            'email': 'email_phishing_score',
            'spear': 'spear_phishing_score',
            'qr': 'qr_phishing_score',
            'sms': 'sms_phishing_score'
        }

        attr_name = vector_map.get(vector_type, 'email_phishing_score')
        current_score = getattr(profile, attr_name, 50.0)
        new_score = max(0, min(100, current_score + impact))
        setattr(profile, attr_name, new_score)

    def _update_technique_score(self, profile: VulnerabilityProfile, technique: str, impact: float):
        """Update the susceptibility score for a specific technique"""
        technique_map = {
            'urgency': 'urgency_susceptibility',
            'authority': 'authority_susceptibility',
            'curiosity': 'curiosity_susceptibility',
            'fear': 'fear_susceptibility',
            'reward': 'reward_susceptibility',
            'social_proof': 'social_proof_susceptibility'
        }

        attr_name = technique_map.get(technique)
        if attr_name:
            current_score = getattr(profile, attr_name, 50.0)
            new_score = max(0, min(100, current_score + impact))
            setattr(profile, attr_name, new_score)

    def _recalculate_overall_score(self, profile: VulnerabilityProfile):
        """Recalculate overall vulnerability score from all factors"""
        # Weight vectors (email is most common)
        vector_weight = 0.4
        technique_weight = 0.4
        behavior_weight = 0.2

        # Average vector scores
        vector_scores = [
            profile.email_phishing_score,
            profile.spear_phishing_score,
            profile.qr_phishing_score,
            profile.sms_phishing_score
        ]
        avg_vector = sum(vector_scores) / len(vector_scores)

        # Average technique scores
        technique_scores = [
            profile.urgency_susceptibility,
            profile.authority_susceptibility,
            profile.curiosity_susceptibility,
            profile.fear_susceptibility,
            profile.reward_susceptibility,
            profile.social_proof_susceptibility
        ]
        avg_technique = sum(technique_scores) / len(technique_scores)

        # Behavior score (based on click rate and credential submission)
        behavior_score = 50.0
        if profile.total_campaigns_received > 0:
            click_rate = profile.total_links_clicked / profile.total_campaigns_received
            cred_rate = profile.total_credentials_submitted / profile.total_campaigns_received
            behavior_score = (click_rate * 70 + cred_rate * 30) * 100

        # Weighted average
        profile.overall_vulnerability_score = (
            avg_vector * vector_weight +
            avg_technique * technique_weight +
            behavior_score * behavior_weight
        )

        # Add penalty for repeat offenders
        if profile.consecutive_failures >= 3:
            profile.overall_vulnerability_score += 10

        # Clamp to 0-100
        profile.overall_vulnerability_score = max(0, min(100, profile.overall_vulnerability_score))

    def _update_temporal_patterns(
        self,
        profile: VulnerabilityProfile,
        time_of_day: str,
        day_of_week: str,
        link_clicked: bool
    ):
        """Track when the employee is most vulnerable"""
        patterns = json.loads(profile.temporal_patterns) if profile.temporal_patterns else {
            'time_of_day': {},
            'day_of_week': {}
        }

        # Initialize if needed
        if 'time_of_day' not in patterns:
            patterns['time_of_day'] = {}
        if 'day_of_week' not in patterns:
            patterns['day_of_week'] = {}

        # Update time of day stats
        if time_of_day not in patterns['time_of_day']:
            patterns['time_of_day'][time_of_day] = {'total': 0, 'clicked': 0}
        patterns['time_of_day'][time_of_day]['total'] += 1
        if link_clicked:
            patterns['time_of_day'][time_of_day]['clicked'] += 1

        # Update day of week stats
        if day_of_week not in patterns['day_of_week']:
            patterns['day_of_week'][day_of_week] = {'total': 0, 'clicked': 0}
        patterns['day_of_week'][day_of_week]['total'] += 1
        if link_clicked:
            patterns['day_of_week'][day_of_week]['clicked'] += 1

        profile.temporal_patterns = json.dumps(patterns)

    def _calculate_improvement_trend(self, profile: VulnerabilityProfile, lookback_days: int = 30):
        """Analyze if employee security awareness is improving"""
        if profile.data_points_count < 4:
            profile.improvement_trend = 'stable'
            return

        # Get recent data points
        cutoff = datetime.utcnow() - timedelta(days=lookback_days)
        recent_points = ProfileDataPoint.query.filter(
            ProfileDataPoint.profile_id == profile.id,
            ProfileDataPoint.recorded_at >= cutoff
        ).order_by(ProfileDataPoint.recorded_at.asc()).all()

        if len(recent_points) < 4:
            profile.improvement_trend = 'stable'
            return

        # Split into first half and second half
        mid = len(recent_points) // 2
        first_half = recent_points[:mid]
        second_half = recent_points[mid:]

        # Calculate click rates for each half
        first_clicks = sum(1 for dp in first_half if dp.link_clicked)
        second_clicks = sum(1 for dp in second_half if dp.link_clicked)

        first_rate = first_clicks / len(first_half) if first_half else 0
        second_rate = second_clicks / len(second_half) if second_half else 0

        # Determine trend
        if second_rate < first_rate - 0.1:  # 10% improvement threshold
            profile.improvement_trend = 'improving'
        elif second_rate > first_rate + 0.1:  # 10% decline threshold
            profile.improvement_trend = 'declining'
        else:
            profile.improvement_trend = 'stable'

    def _get_time_of_day(self, dt: datetime) -> str:
        """Categorize time into morning/afternoon/evening/night"""
        hour = dt.hour
        if 5 <= hour < 12:
            return 'morning'
        elif 12 <= hour < 17:
            return 'afternoon'
        elif 17 <= hour < 21:
            return 'evening'
        else:
            return 'night'

    def calculate_department_vulnerability(self, department: str) -> DepartmentVulnerability:
        """
        Calculate aggregated vulnerability metrics for a department.
        """
        # Get or create department record
        dept_vuln = DepartmentVulnerability.query.filter_by(department=department).first()
        if not dept_vuln:
            dept_vuln = DepartmentVulnerability(department=department)
            db.session.add(dept_vuln)

        # Get all employees in department
        employees = Employee.query.filter_by(department=department, is_active=True).all()
        dept_vuln.employee_count = len(employees)

        if not employees:
            db.session.commit()
            return dept_vuln

        # Get profiles for employees
        employee_ids = [e.id for e in employees]
        profiles = VulnerabilityProfile.query.filter(
            VulnerabilityProfile.employee_id.in_(employee_ids)
        ).all()

        dept_vuln.profiled_employee_count = len(profiles)

        if not profiles:
            db.session.commit()
            return dept_vuln

        # Store previous score for trend calculation
        dept_vuln.previous_avg_score = dept_vuln.avg_vulnerability_score

        # Calculate averages
        dept_vuln.avg_vulnerability_score = sum(p.overall_vulnerability_score for p in profiles) / len(profiles)

        # Count high risk
        dept_vuln.high_risk_count = sum(1 for p in profiles if p.overall_vulnerability_score > 70)

        # Attack vector averages
        dept_vuln.email_phishing_avg = sum(p.email_phishing_score for p in profiles) / len(profiles)
        dept_vuln.spear_phishing_avg = sum(p.spear_phishing_score for p in profiles) / len(profiles)
        dept_vuln.qr_phishing_avg = sum(p.qr_phishing_score for p in profiles) / len(profiles)
        dept_vuln.sms_phishing_avg = sum(p.sms_phishing_score for p in profiles) / len(profiles)

        # Technique averages
        dept_vuln.urgency_avg = sum(p.urgency_susceptibility for p in profiles) / len(profiles)
        dept_vuln.authority_avg = sum(p.authority_susceptibility for p in profiles) / len(profiles)
        dept_vuln.curiosity_avg = sum(p.curiosity_susceptibility for p in profiles) / len(profiles)
        dept_vuln.fear_avg = sum(p.fear_susceptibility for p in profiles) / len(profiles)
        dept_vuln.reward_avg = sum(p.reward_susceptibility for p in profiles) / len(profiles)
        dept_vuln.social_proof_avg = sum(p.social_proof_susceptibility for p in profiles) / len(profiles)

        # Find weakest areas
        techniques = {
            'urgency': dept_vuln.urgency_avg,
            'authority': dept_vuln.authority_avg,
            'curiosity': dept_vuln.curiosity_avg,
            'fear': dept_vuln.fear_avg,
            'reward': dept_vuln.reward_avg,
            'social_proof': dept_vuln.social_proof_avg
        }
        vectors = {
            'email': dept_vuln.email_phishing_avg,
            'spear': dept_vuln.spear_phishing_avg,
            'qr': dept_vuln.qr_phishing_avg,
            'sms': dept_vuln.sms_phishing_avg
        }

        dept_vuln.weakest_technique = max(techniques, key=techniques.get)
        dept_vuln.weakest_technique_score = techniques[dept_vuln.weakest_technique]
        dept_vuln.weakest_vector = max(vectors, key=vectors.get)
        dept_vuln.weakest_vector_score = vectors[dept_vuln.weakest_vector]

        # Calculate campaign metrics
        total_campaigns = sum(p.total_campaigns_received for p in profiles)
        total_clicks = sum(p.total_links_clicked for p in profiles)
        total_submissions = sum(p.total_credentials_submitted for p in profiles)

        dept_vuln.total_campaigns = total_campaigns
        dept_vuln.overall_click_rate = (total_clicks / total_campaigns * 100) if total_campaigns > 0 else 0
        dept_vuln.overall_submission_rate = (total_submissions / total_campaigns * 100) if total_campaigns > 0 else 0

        # Calculate trend
        if dept_vuln.previous_avg_score is not None:
            diff = dept_vuln.avg_vulnerability_score - dept_vuln.previous_avg_score
            if diff < -5:
                dept_vuln.trend = 'improving'
            elif diff > 5:
                dept_vuln.trend = 'declining'
            else:
                dept_vuln.trend = 'stable'

        dept_vuln.last_calculated = datetime.utcnow()
        db.session.commit()

        return dept_vuln

    def calculate_age_group_vulnerability(self, age_group: str) -> AgeGroupVulnerability:
        """
        Calculate vulnerability patterns for an age group.
        """
        # Get or create age group record
        age_vuln = AgeGroupVulnerability.query.filter_by(age_group=age_group).first()
        if not age_vuln:
            age_vuln = AgeGroupVulnerability(age_group=age_group)
            db.session.add(age_vuln)

        # Get all employees in age group
        employees = Employee.query.filter_by(age_group=age_group, is_active=True).all()
        age_vuln.employee_count = len(employees)

        if not employees:
            db.session.commit()
            return age_vuln

        # Get profiles
        employee_ids = [e.id for e in employees]
        profiles = VulnerabilityProfile.query.filter(
            VulnerabilityProfile.employee_id.in_(employee_ids)
        ).all()

        if not profiles:
            db.session.commit()
            return age_vuln

        # Calculate averages
        age_vuln.avg_vulnerability_score = sum(p.overall_vulnerability_score for p in profiles) / len(profiles)

        # Vector susceptibility
        age_vuln.email_susceptibility = sum(p.email_phishing_score for p in profiles) / len(profiles)
        age_vuln.qr_susceptibility = sum(p.qr_phishing_score for p in profiles) / len(profiles)
        age_vuln.sms_susceptibility = sum(p.sms_phishing_score for p in profiles) / len(profiles)

        # Technique effectiveness (higher score = more effective against this group)
        age_vuln.urgency_effectiveness = sum(p.urgency_susceptibility for p in profiles) / len(profiles)
        age_vuln.authority_effectiveness = sum(p.authority_susceptibility for p in profiles) / len(profiles)
        age_vuln.curiosity_effectiveness = sum(p.curiosity_susceptibility for p in profiles) / len(profiles)
        age_vuln.fear_effectiveness = sum(p.fear_susceptibility for p in profiles) / len(profiles)
        age_vuln.reward_effectiveness = sum(p.reward_susceptibility for p in profiles) / len(profiles)
        age_vuln.social_proof_effectiveness = sum(p.social_proof_susceptibility for p in profiles) / len(profiles)

        # Find most effective methods
        techniques = {
            'urgency': age_vuln.urgency_effectiveness,
            'authority': age_vuln.authority_effectiveness,
            'curiosity': age_vuln.curiosity_effectiveness,
            'fear': age_vuln.fear_effectiveness,
            'reward': age_vuln.reward_effectiveness,
            'social_proof': age_vuln.social_proof_effectiveness
        }
        vectors = {
            'email': age_vuln.email_susceptibility,
            'qr': age_vuln.qr_susceptibility,
            'sms': age_vuln.sms_susceptibility
        }

        age_vuln.most_effective_technique = max(techniques, key=techniques.get)
        age_vuln.technique_effectiveness_score = techniques[age_vuln.most_effective_technique]
        age_vuln.most_effective_vector = max(vectors, key=vectors.get)
        age_vuln.vector_effectiveness_score = vectors[age_vuln.most_effective_vector]

        # Behavioral patterns
        avg_response_times = [p.avg_click_time_seconds for p in profiles if p.avg_click_time_seconds]
        if avg_response_times:
            age_vuln.avg_response_time_seconds = sum(avg_response_times) / len(avg_response_times)

        total_campaigns = sum(p.total_campaigns_received for p in profiles)
        total_clicks = sum(p.total_links_clicked for p in profiles)
        total_submissions = sum(p.total_credentials_submitted for p in profiles)

        age_vuln.click_rate = (total_clicks / total_campaigns * 100) if total_campaigns > 0 else 0
        age_vuln.credential_submission_rate = (total_submissions / total_campaigns * 100) if total_campaigns > 0 else 0

        age_vuln.last_calculated = datetime.utcnow()
        db.session.commit()

        return age_vuln

    def recalculate_all_profiles(self) -> Dict:
        """
        Batch recalculation of all vulnerability profiles.
        Should be run after importing historical data or on a schedule.
        """
        results = {
            'profiles_updated': 0,
            'departments_updated': 0,
            'age_groups_updated': 0
        }

        # Recalculate all individual profiles
        profiles = VulnerabilityProfile.query.all()
        for profile in profiles:
            profile.find_weakest_areas()
            profile.calculate_profile_confidence()
            profile.calculate_risk_level()
            self._calculate_improvement_trend(profile)
            results['profiles_updated'] += 1

        db.session.commit()

        # Recalculate all department vulnerabilities
        departments = db.session.query(Employee.department).filter(
            Employee.department.isnot(None),
            Employee.is_active == True
        ).distinct().all()

        for (department,) in departments:
            self.calculate_department_vulnerability(department)
            results['departments_updated'] += 1

        # Recalculate all age group vulnerabilities
        age_groups = db.session.query(Employee.age_group).filter(
            Employee.age_group.isnot(None),
            Employee.is_active == True
        ).distinct().all()

        for (age_group,) in age_groups:
            self.calculate_age_group_vulnerability(age_group)
            results['age_groups_updated'] += 1

        return results

    def get_employee_vulnerability_summary(self, employee_id: str) -> Optional[Dict]:
        """Get a comprehensive vulnerability summary for an employee"""
        profile = VulnerabilityProfile.query.filter_by(employee_id=employee_id).first()
        if not profile:
            return None

        employee = Employee.query.get(employee_id)
        if not employee:
            return None

        # Get recommended training areas based on weaknesses
        recommended_training = self._get_recommended_training(profile)

        return {
            'employee': employee.to_dict(),
            'profile': profile.to_dict(),
            'recommended_training': recommended_training,
            'summary': {
                'risk_level': profile.risk_level,
                'overall_score': profile.overall_vulnerability_score,
                'weakest_technique': profile.weakest_technique,
                'weakest_vector': profile.weakest_vector,
                'trend': profile.improvement_trend,
                'confidence': profile.profile_confidence
            }
        }

    def _get_recommended_training(self, profile: VulnerabilityProfile) -> List[str]:
        """Generate training recommendations based on vulnerability profile"""
        recommendations = []

        # Check technique susceptibilities
        techniques = {
            'urgency': ('Urgency Recognition Training', profile.urgency_susceptibility),
            'authority': ('Authority Verification Training', profile.authority_susceptibility),
            'curiosity': ('Curiosity-Based Attack Awareness', profile.curiosity_susceptibility),
            'fear': ('Fear Tactics Recognition', profile.fear_susceptibility),
            'reward': ('Reward Scam Awareness', profile.reward_susceptibility),
            'social_proof': ('Social Engineering Defense', profile.social_proof_susceptibility)
        }

        # Recommend training for high susceptibility areas (>60)
        for technique, (training_name, score) in techniques.items():
            if score > 60:
                recommendations.append(training_name)

        # Check vector vulnerabilities
        if profile.qr_phishing_score > 60:
            recommendations.append('QR Code Security Awareness')
        if profile.sms_phishing_score > 60:
            recommendations.append('SMS Phishing (Smishing) Defense')

        # General recommendations based on behavior
        if profile.avg_click_time_seconds and profile.avg_click_time_seconds < 30:
            recommendations.append('Slow Down & Verify Training')

        if profile.consecutive_failures >= 3:
            recommendations.append('Intensive Security Awareness Program')

        return recommendations[:5]  # Limit to top 5 recommendations

    def get_high_risk_employees(self, threshold: float = 70.0, limit: int = 20) -> List[Dict]:
        """Get list of highest risk employees"""
        profiles = VulnerabilityProfile.query.filter(
            VulnerabilityProfile.overall_vulnerability_score >= threshold
        ).order_by(
            VulnerabilityProfile.overall_vulnerability_score.desc()
        ).limit(limit).all()

        results = []
        for profile in profiles:
            employee = Employee.query.get(profile.employee_id)
            if employee:
                results.append({
                    'employee': employee.to_dict(),
                    'profile_summary': {
                        'overall_score': profile.overall_vulnerability_score,
                        'risk_level': profile.risk_level,
                        'weakest_technique': profile.weakest_technique,
                        'consecutive_failures': profile.consecutive_failures,
                        'trend': profile.improvement_trend
                    }
                })

        return results

    def get_organization_summary(self) -> Dict:
        """Get organization-wide vulnerability statistics"""
        profiles = VulnerabilityProfile.query.all()
        total_employees = Employee.query.filter_by(is_active=True).count()

        if not profiles:
            return {
                'total_employees': total_employees,
                'profiled_employees': 0,
                'avg_vulnerability_score': 50.0,
                'risk_distribution': {'low': 0, 'medium': 0, 'high': 0, 'critical': 0},
                'top_weaknesses': [],
                'improvement_trend': 'stable'
            }

        # Calculate averages
        avg_score = sum(p.overall_vulnerability_score for p in profiles) / len(profiles)

        # Risk distribution
        risk_dist = {'low': 0, 'medium': 0, 'high': 0, 'critical': 0}
        for p in profiles:
            risk_dist[p.risk_level] = risk_dist.get(p.risk_level, 0) + 1

        # Find top weaknesses across organization
        technique_totals = {
            'urgency': sum(p.urgency_susceptibility for p in profiles),
            'authority': sum(p.authority_susceptibility for p in profiles),
            'curiosity': sum(p.curiosity_susceptibility for p in profiles),
            'fear': sum(p.fear_susceptibility for p in profiles),
            'reward': sum(p.reward_susceptibility for p in profiles),
            'social_proof': sum(p.social_proof_susceptibility for p in profiles)
        }
        top_weaknesses = sorted(technique_totals.items(), key=lambda x: x[1], reverse=True)[:3]

        # Overall trend
        improving = sum(1 for p in profiles if p.improvement_trend == 'improving')
        declining = sum(1 for p in profiles if p.improvement_trend == 'declining')

        if improving > declining + len(profiles) * 0.1:
            org_trend = 'improving'
        elif declining > improving + len(profiles) * 0.1:
            org_trend = 'declining'
        else:
            org_trend = 'stable'

        return {
            'total_employees': total_employees,
            'profiled_employees': len(profiles),
            'avg_vulnerability_score': round(avg_score, 1),
            'risk_distribution': risk_dist,
            'top_weaknesses': [{'technique': t, 'avg_score': round(s / len(profiles), 1)} for t, s in top_weaknesses],
            'improvement_trend': org_trend
        }
